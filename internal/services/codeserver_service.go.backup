package services

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/chrishham/xanthus/internal/models"
	"github.com/chrishham/xanthus/internal/utils"
)

// CodeServerDeploymentStrategy implements deployment strategy for code-server applications
type CodeServerDeploymentStrategy struct {
	*BaseDeploymentStrategy
}

// NewCodeServerDeploymentStrategy creates a new CodeServerDeploymentStrategy
func NewCodeServerDeploymentStrategy(passwordService PasswordService) DeploymentStrategy {
	return &CodeServerDeploymentStrategy{
		BaseDeploymentStrategy: NewBaseDeploymentStrategy(passwordService),
	}
}

// Deploy implements code-server specific deployment
func (s *CodeServerDeploymentStrategy) Deploy(conn *SSHConnection, app *models.Application, predefinedApp *models.PredefinedApplication) error {
	// Execute base deployment
	if err := s.BaseDeploymentStrategy.Deploy(conn, app, predefinedApp); err != nil {
		return err
	}

	// Create VS Code settings ConfigMap
	releaseName := fmt.Sprintf("%s-%s", app.AppType, app.ID)
	if err := s.createVSCodeSettingsConfigMap(conn, releaseName, app.Namespace); err != nil {
		return fmt.Errorf("failed to create VS Code settings: %w", err)
	}

	return nil
}

// Upgrade implements code-server specific upgrade
func (s *CodeServerDeploymentStrategy) Upgrade(conn *SSHConnection, app *models.Application, version string) error {
	releaseName := fmt.Sprintf("%s-%s", app.AppType, app.ID)
	
	// Get current Helm values
	getCurrentValuesCmd := fmt.Sprintf("helm get values %s -n %s --output json", releaseName, app.Namespace)
	currentValuesJSON, err := conn.Execute(getCurrentValuesCmd)
	if err != nil {
		return fmt.Errorf("failed to get current Helm values: %w", err)
	}

	// Parse current values
	var currentValues map[string]interface{}
	if err := json.Unmarshal([]byte(currentValuesJSON), &currentValues); err != nil {
		return fmt.Errorf("failed to parse current values: %w", err)
	}

	// Update image tag
	if currentValues["image"] == nil {
		currentValues["image"] = make(map[string]interface{})
	}
	imageConfig := currentValues["image"].(map[string]interface{})
	imageConfig["tag"] = version

	// Write updated values to file
	updatedValuesJSON, err := json.Marshal(currentValues)
	if err != nil {
		return fmt.Errorf("failed to marshal updated values: %w", err)
	}

	valuesFile := fmt.Sprintf("/tmp/codeserver-upgrade-values-%s.json", app.ID)
	writeCmd := fmt.Sprintf("echo '%s' > %s", string(updatedValuesJSON), valuesFile)
	if _, err := conn.Execute(writeCmd); err != nil {
		return fmt.Errorf("failed to write updated values: %w", err)
	}

	// Upgrade using Helm
	upgradeCmd := fmt.Sprintf("helm upgrade %s codercom/code-server -n %s -f %s --wait --timeout=10m", 
		releaseName, app.Namespace, valuesFile)
	
	if _, err := conn.Execute(upgradeCmd); err != nil {
		return fmt.Errorf("failed to upgrade code-server: %w", err)
	}

	// Clean up values file
	cleanupCmd := fmt.Sprintf("rm -f %s", valuesFile)
	conn.Execute(cleanupCmd) // Ignore cleanup errors

	return nil
}

// ValidateVersion validates code-server version against GitHub releases
func (s *CodeServerDeploymentStrategy) ValidateVersion(version string) (bool, error) {
	if strings.TrimSpace(version) == "" {
		return false, fmt.Errorf("version cannot be empty")
	}

	// Get GitHub releases for code-server
	releases, err := utils.GetGithubReleases("coder", "code-server")
	if err != nil {
		return false, fmt.Errorf("failed to get GitHub releases: %w", err)
	}

	// Check if version exists in releases
	for _, release := range releases {
		if release.TagName == version || strings.TrimPrefix(release.TagName, "v") == version {
			return true, nil
		}
	}

	return false, fmt.Errorf("version %s not found in GitHub releases", version)
}

// createVSCodeSettingsConfigMap creates a ConfigMap with default VS Code settings
func (s *CodeServerDeploymentStrategy) createVSCodeSettingsConfigMap(conn *SSHConnection, releaseName, namespace string) error {
	// Default VS Code settings
	settings := map[string]string{
		"settings.json": `{
  "workbench.colorTheme": "Default Dark+",
  "editor.fontSize": 14,
  "editor.fontFamily": "'Fira Code', 'Cascadia Code', 'JetBrains Mono', Consolas, 'Courier New', monospace",
  "editor.fontLigatures": true,
  "editor.tabSize": 2,
  "editor.insertSpaces": true,
  "editor.wordWrap": "on",
  "editor.minimap.enabled": true,
  "editor.renderWhitespace": "boundary",
  "editor.rulers": [80, 120],
  "files.autoSave": "afterDelay",
  "files.autoSaveDelay": 1000,
  "terminal.integrated.shell.linux": "/bin/bash",
  "extensions.autoUpdate": false,
  "extensions.autoCheckUpdates": false,
  "telemetry.enableTelemetry": false,
  "telemetry.enableCrashReporter": false
}`,
		"keybindings.json": `[
  {
    "key": "ctrl+shift+c",
    "command": "workbench.action.terminal.copySelection",
    "when": "terminalFocus && terminalTextSelected"
  },
  {
    "key": "ctrl+shift+v",
    "command": "workbench.action.terminal.paste",
    "when": "terminalFocus"
  }
]`,
	}

	// Create ConfigMap
	configMapName := fmt.Sprintf("%s-vscode-settings", releaseName)
	return CreateConfigMap(conn, configMapName, namespace, settings)
}

// CodeServerService provides code-server specific operations
type CodeServerService interface {
	// GetVersions returns available code-server versions from GitHub
	GetVersions() ([]models.VersionInfo, error)
	
	// GetPassword retrieves the code-server password
	GetPassword(token, accountID, appID string) (string, error)
	
	// UpdatePassword updates the code-server password
	UpdatePassword(token, accountID, appID, newPassword string) error
	
	// GetWorkspaceInfo returns workspace information
	GetWorkspaceInfo(token, accountID, appID string) (*CodeServerWorkspaceInfo, error)
}

// CodeServerWorkspaceInfo contains information about a code-server workspace
type CodeServerWorkspaceInfo struct {
	WorkspaceDir    string   `json:"workspace_dir"`
	Extensions      []string `json:"extensions"`
	Settings        string   `json:"settings"`
	RecentFiles     []string `json:"recent_files"`
	ActiveProjects  []string `json:"active_projects"`
}

// DefaultCodeServerService implements CodeServerService
type DefaultCodeServerService struct {
	appService      ApplicationService
	passwordService PasswordService
	vpsService      VPSService
	sshService      SSHService
}

// NewCodeServerService creates a new DefaultCodeServerService
func NewCodeServerService(appService ApplicationService, passwordService PasswordService) CodeServerService {
	return &DefaultCodeServerService{
		appService:      appService,
		passwordService: passwordService,
		vpsService:      NewVPSService(),
		sshService:      NewSSHService(),
	}
}

// GetVersions returns available code-server versions from GitHub
func (s *DefaultCodeServerService) GetVersions() ([]models.VersionInfo, error) {
	releases, err := utils.GetGithubReleases("coder", "code-server")
	if err != nil {
		return nil, fmt.Errorf("failed to get releases: %w", err)
	}

	var versions []models.VersionInfo
	for i, release := range releases {
		version := models.VersionInfo{
			Version:     release.TagName,
			Name:        release.Name,
			IsLatest:    i == 0,
			IsStable:    !release.Prerelease,
			PublishedAt: release.PublishedAt,
			URL:         release.HTMLURL,
		}
		versions = append(versions, version)
	}

	return versions, nil
}

// GetPassword retrieves the code-server password
func (s *DefaultCodeServerService) GetPassword(token, accountID, appID string) (string, error) {
	return s.passwordService.Get(token, accountID, appID, "code-server")
}

// UpdatePassword updates the code-server password
func (s *DefaultCodeServerService) UpdatePassword(token, accountID, appID, newPassword string) error {
	return s.passwordService.Update(token, accountID, appID, "code-server", newPassword)
}

// GetWorkspaceInfo returns workspace information
func (s *DefaultCodeServerService) GetWorkspaceInfo(token, accountID, appID string) (*CodeServerWorkspaceInfo, error) {
	// Get application
	app, err := s.appService.Get(token, accountID, appID)
	if err != nil {
		return nil, fmt.Errorf("failed to get application: %w", err)
	}

	// Get VPS connection details
	vpsDetails, err := s.vpsService.GetVPSDetails(token, accountID, app.VPSID)
	if err != nil {
		return nil, fmt.Errorf("failed to get VPS details: %w", err)
	}

	// Establish SSH connection
	conn, err := s.sshService.Connect(vpsDetails.IPAddress, "root", vpsDetails.PrivateKey)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to VPS: %w", err)
	}
	defer conn.Close()

	// Get workspace information
	releaseName := fmt.Sprintf("%s-%s", app.AppType, app.ID)
	podName, err := s.getPodName(conn, releaseName, app.Namespace)
	if err != nil {
		return nil, fmt.Errorf("failed to get pod name: %w", err)
	}

	info := &CodeServerWorkspaceInfo{}

	// Get workspace directory
	workspaceDirCmd := fmt.Sprintf("kubectl exec %s -n %s -- pwd", podName, app.Namespace)
	if workspaceDir, err := conn.Execute(workspaceDirCmd); err == nil {
		info.WorkspaceDir = strings.TrimSpace(workspaceDir)
	}

	// Get installed extensions
	extensionsCmd := fmt.Sprintf("kubectl exec %s -n %s -- code-server --list-extensions", podName, app.Namespace)
	if extensionsOutput, err := conn.Execute(extensionsCmd); err == nil {
		extensions := strings.Split(strings.TrimSpace(extensionsOutput), "\n")
		for _, ext := range extensions {
			if ext != "" {
				info.Extensions = append(info.Extensions, ext)
			}
		}
	}

	// Get settings
	settingsCmd := fmt.Sprintf("kubectl exec %s -n %s -- cat ~/.local/share/code-server/User/settings.json 2>/dev/null || echo '{}'", 
		podName, app.Namespace)
	if settings, err := conn.Execute(settingsCmd); err == nil {
		info.Settings = strings.TrimSpace(settings)
	}

	return info, nil
}

// getPodName gets the pod name for a code-server deployment
func (s *DefaultCodeServerService) getPodName(conn *SSHConnection, releaseName, namespace string) (string, error) {
	getPodCmd := fmt.Sprintf("kubectl get pods -n %s -l app.kubernetes.io/instance=%s -o jsonpath='{.items[0].metadata.name}'", 
		namespace, releaseName)
	
	podName, err := conn.Execute(getPodCmd)
	if err != nil {
		return "", fmt.Errorf("failed to get pod name: %w", err)
	}

	podName = strings.TrimSpace(podName)
	if podName == "" {
		return "", fmt.Errorf("no pod found for release %s", releaseName)
	}

	return podName, nil
}