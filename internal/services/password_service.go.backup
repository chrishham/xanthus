package services

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/chrishham/xanthus/internal/utils"
)

// PasswordService manages application passwords across different application types
type PasswordService interface {
	// Get retrieves a password for a specific application
	Get(token, accountID, appID, appType string) (string, error)
	
	// Update changes the password for a specific application
	Update(token, accountID, appID, appType, newPassword string) error
	
	// RetrieveAndStoreCodeServerPassword retrieves auto-generated code-server password from Kubernetes
	RetrieveAndStoreCodeServerPassword(token, accountID, appID, releaseName, namespace string, conn *SSHConnection) error
	
	// RetrieveAndStoreArgoCDPassword retrieves auto-generated ArgoCD password from Kubernetes
	RetrieveAndStoreArgoCDPassword(token, accountID, appID, releaseName, namespace string, conn *SSHConnection) error
	
	// UpdateCodeServerPassword updates code-server password via Kubernetes secret
	UpdateCodeServerPassword(token, accountID, appID, newPassword string, conn *SSHConnection, namespace string) error
	
	// UpdateArgoCDPassword updates ArgoCD password using Helm values
	UpdateArgoCDPassword(token, accountID, appID, newPassword string, conn *SSHConnection, releaseName, namespace string) error
}

// DefaultPasswordService implements PasswordService
type DefaultPasswordService struct {
	appService ApplicationService
}

// NewPasswordService creates a new DefaultPasswordService
func NewPasswordService(appService ApplicationService) PasswordService {
	return &DefaultPasswordService{
		appService: appService,
	}
}

// Get retrieves a password for a specific application
func (s *DefaultPasswordService) Get(token, accountID, appID, appType string) (string, error) {
	switch appType {
	case "code-server":
		return s.getCodeServerPassword(token, accountID, appID)
	case "argocd":
		return s.getArgoCDPassword(token, accountID, appID)
	default:
		return "", fmt.Errorf("password retrieval not supported for application type: %s", appType)
	}
}

// Update changes the password for a specific application
func (s *DefaultPasswordService) Update(token, accountID, appID, appType, newPassword string) error {
	// Get application details
	app, err := s.appService.Get(token, accountID, appID)
	if err != nil {
		return fmt.Errorf("failed to get application: %w", err)
	}

	// Get VPS connection details
	vpsService := NewVPSService()
	vpsDetails, err := vpsService.GetVPSDetails(token, accountID, app.VPSID)
	if err != nil {
		return fmt.Errorf("failed to get VPS details: %w", err)
	}

	// Establish SSH connection
	sshService := NewSSHService()
	conn, err := sshService.Connect(vpsDetails.IPAddress, "root", vpsDetails.PrivateKey)
	if err != nil {
		return fmt.Errorf("failed to connect to VPS: %w", err)
	}
	defer conn.Close()

	// Update password based on application type
	switch appType {
	case "code-server":
		return s.UpdateCodeServerPassword(token, accountID, appID, newPassword, conn, app.Namespace)
	case "argocd":
		releaseName := fmt.Sprintf("%s-%s", app.AppType, app.ID)
		return s.UpdateArgoCDPassword(token, accountID, appID, newPassword, conn, releaseName, app.Namespace)
	default:
		return fmt.Errorf("password update not supported for application type: %s", appType)
	}
}

// RetrieveAndStoreCodeServerPassword retrieves auto-generated code-server password from Kubernetes
func (s *DefaultPasswordService) RetrieveAndStoreCodeServerPassword(token, accountID, appID, releaseName, namespace string, conn *SSHConnection) error {
	// Get the password from the secret
	getPasswordCmd := fmt.Sprintf("kubectl get secret %s -n %s -o jsonpath='{.data.password}' | base64 -d", 
		releaseName, namespace)
	
	password, err := conn.Execute(getPasswordCmd)
	if err != nil {
		return fmt.Errorf("failed to retrieve code-server password: %w", err)
	}

	password = strings.TrimSpace(password)
	if password == "" {
		return fmt.Errorf("retrieved empty password for code-server")
	}

	// Encrypt and store the password
	encryptedPassword, err := utils.EncryptPassword(password)
	if err != nil {
		return fmt.Errorf("failed to encrypt password: %w", err)
	}

	kvKey := fmt.Sprintf("app_password_%s_%s", accountID, appID)
	return utils.SetKVValue(token, accountID, kvKey, encryptedPassword)
}

// RetrieveAndStoreArgoCDPassword retrieves auto-generated ArgoCD password from Kubernetes
func (s *DefaultPasswordService) RetrieveAndStoreArgoCDPassword(token, accountID, appID, releaseName, namespace string, conn *SSHConnection) error {
	// Try to get password from secret first
	getPasswordCmd := fmt.Sprintf("kubectl get secret %s-argocd-initial-admin-secret -n %s -o jsonpath='{.data.password}' 2>/dev/null | base64 -d", 
		releaseName, namespace)
	
	password, err := conn.Execute(getPasswordCmd)
	if err != nil || strings.TrimSpace(password) == "" {
		// If secret doesn't exist, try alternative method
		getPasswordCmd = fmt.Sprintf("kubectl -n %s get pods -l app.kubernetes.io/name=argocd-server -o name | head -1 | xargs -I {} kubectl -n %s exec {} -- argocd admin initial-password -p", 
			namespace, namespace)
		
		password, err = conn.Execute(getPasswordCmd)
		if err != nil {
			return fmt.Errorf("failed to retrieve ArgoCD password: %w", err)
		}
	}

	password = strings.TrimSpace(password)
	if password == "" {
		return fmt.Errorf("retrieved empty password for ArgoCD")
	}

	// Encrypt and store the password
	encryptedPassword, err := utils.EncryptPassword(password)
	if err != nil {
		return fmt.Errorf("failed to encrypt password: %w", err)
	}

	kvKey := fmt.Sprintf("app_password_%s_%s", accountID, appID)
	return utils.SetKVValue(token, accountID, kvKey, encryptedPassword)
}

// UpdateCodeServerPassword updates code-server password via Kubernetes secret
func (s *DefaultPasswordService) UpdateCodeServerPassword(token, accountID, appID, newPassword string, conn *SSHConnection, namespace string) error {
	// Get application details to find the release name
	app, err := s.appService.Get(token, accountID, appID)
	if err != nil {
		return fmt.Errorf("failed to get application: %w", err)
	}

	releaseName := fmt.Sprintf("%s-%s", app.AppType, app.ID)

	// Update the Kubernetes secret
	updateSecretCmd := fmt.Sprintf("kubectl patch secret %s -n %s -p '{\"data\":{\"password\":\"%s\"}}'", 
		releaseName, namespace, utils.Base64Encode(newPassword))
	
	if _, err := conn.Execute(updateSecretCmd); err != nil {
		return fmt.Errorf("failed to update code-server secret: %w", err)
	}

	// Restart the deployment to pick up the new password
	restartCmd := fmt.Sprintf("kubectl rollout restart deployment %s -n %s", releaseName, namespace)
	if _, err := conn.Execute(restartCmd); err != nil {
		return fmt.Errorf("failed to restart code-server deployment: %w", err)
	}

	// Encrypt and store the new password
	encryptedPassword, err := utils.EncryptPassword(newPassword)
	if err != nil {
		return fmt.Errorf("failed to encrypt password: %w", err)
	}

	kvKey := fmt.Sprintf("app_password_%s_%s", accountID, appID)
	return utils.SetKVValue(token, accountID, kvKey, encryptedPassword)
}

// UpdateArgoCDPassword updates ArgoCD password using Helm values
func (s *DefaultPasswordService) UpdateArgoCDPassword(token, accountID, appID, newPassword string, conn *SSHConnection, releaseName, namespace string) error {
	// Hash the password using bcrypt (ArgoCD requirement)
	hashCmd := fmt.Sprintf("python3 -c 'import bcrypt; print(bcrypt.hashpw(\"%s\".encode(\"utf-8\"), bcrypt.gensalt()).decode(\"utf-8\"))'", 
		strings.ReplaceAll(newPassword, "'", "\\'"))
	
	hashedPassword, err := conn.Execute(hashCmd)
	if err != nil {
		return fmt.Errorf("failed to hash password: %w", err)
	}

	hashedPassword = strings.TrimSpace(hashedPassword)

	// Create Helm values to update the password
	values := map[string]interface{}{
		"configs": map[string]interface{}{
			"secret": map[string]interface{}{
				"argocdServerAdminPassword": hashedPassword,
			},
		},
	}

	valuesJSON, err := json.Marshal(values)
	if err != nil {
		return fmt.Errorf("failed to marshal Helm values: %w", err)
	}

	// Write values to a temporary file
	valuesFile := fmt.Sprintf("/tmp/argocd-values-%s.json", appID)
	writeCmd := fmt.Sprintf("echo '%s' > %s", string(valuesJSON), valuesFile)
	if _, err := conn.Execute(writeCmd); err != nil {
		return fmt.Errorf("failed to write values file: %w", err)
	}

	// Update the Helm release
	upgradeCmd := fmt.Sprintf("helm upgrade %s argo/argo-cd -n %s -f %s", 
		releaseName, namespace, valuesFile)
	
	if _, err := conn.Execute(upgradeCmd); err != nil {
		return fmt.Errorf("failed to upgrade ArgoCD with new password: %w", err)
	}

	// Clean up the temporary file
	cleanupCmd := fmt.Sprintf("rm -f %s", valuesFile)
	conn.Execute(cleanupCmd) // Ignore errors for cleanup

	// Encrypt and store the new password
	encryptedPassword, err := utils.EncryptPassword(newPassword)
	if err != nil {
		return fmt.Errorf("failed to encrypt password: %w", err)
	}

	kvKey := fmt.Sprintf("app_password_%s_%s", accountID, appID)
	return utils.SetKVValue(token, accountID, kvKey, encryptedPassword)
}

// getCodeServerPassword retrieves stored code-server password from KV
func (s *DefaultPasswordService) getCodeServerPassword(token, accountID, appID string) (string, error) {
	kvKey := fmt.Sprintf("app_password_%s_%s", accountID, appID)
	encryptedPassword, err := utils.GetKVValue(token, accountID, kvKey)
	if err != nil {
		return "", fmt.Errorf("failed to get encrypted password: %w", err)
	}

	if encryptedPassword == "" {
		return "", fmt.Errorf("password not found for application: %s", appID)
	}

	password, err := utils.DecryptPassword(encryptedPassword)
	if err != nil {
		return "", fmt.Errorf("failed to decrypt password: %w", err)
	}

	return password, nil
}

// getArgoCDPassword retrieves stored ArgoCD password from KV
func (s *DefaultPasswordService) getArgoCDPassword(token, accountID, appID string) (string, error) {
	kvKey := fmt.Sprintf("app_password_%s_%s", accountID, appID)
	encryptedPassword, err := utils.GetKVValue(token, accountID, kvKey)
	if err != nil {
		return "", fmt.Errorf("failed to get encrypted password: %w", err)
	}

	if encryptedPassword == "" {
		return "", fmt.Errorf("password not found for application: %s", appID)
	}

	password, err := utils.DecryptPassword(encryptedPassword)
	if err != nil {
		return "", fmt.Errorf("failed to decrypt password: %w", err)
	}

	return password, nil
}