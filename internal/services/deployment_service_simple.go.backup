package services

import (
	"fmt"
	"log"
	"strings"

	"github.com/chrishham/xanthus/internal/models"
	"github.com/chrishham/xanthus/internal/utils"
)

// SimpleDeploymentService handles application deployments using existing services
type SimpleDeploymentService struct {
	appService *SimpleApplicationService
}

// NewSimpleDeploymentService creates a new SimpleDeploymentService
func NewSimpleDeploymentService(appService *SimpleApplicationService) *SimpleDeploymentService {
	return &SimpleDeploymentService{
		appService: appService,
	}
}

// DeployApplication deploys a predefined application using Helm
func (s *SimpleDeploymentService) DeployApplication(token, accountID string, app *models.Application, predefinedApp *models.PredefinedApplication) error {
	// Update application status to deploying
	app.Status = "Deploying"
	if err := s.appService.UpdateApplication(token, accountID, app); err != nil {
		log.Printf("Warning: failed to update application status: %v", err)
	}

	// Use existing services
	vpsService := NewVPSService()
	sshService := NewSSHService()
	kvService := NewKVService()
	
	// Get VPS configuration
	serverID := utils.ParseInt(app.VPSID)
	vpsConfig, err := vpsService.ValidateVPSAccess(token, accountID, serverID)
	if err != nil {
		return s.handleDeploymentError(token, accountID, app, fmt.Errorf("failed to get VPS config: %w", err))
	}

	// Get SSH private key
	privateKey, err := kvService.GetSSHPrivateKey(token, accountID, serverID)
	if err != nil {
		return s.handleDeploymentError(token, accountID, app, fmt.Errorf("failed to get SSH key: %w", err))
	}

	// Establish SSH connection
	conn, err := sshService.GetOrCreateConnection(vpsConfig.PublicIPv4, vpsConfig.SSHUser, privateKey, serverID)
	if err != nil {
		return s.handleDeploymentError(token, accountID, app, fmt.Errorf("failed to connect to VPS: %w", err))
	}

	// Execute deployment
	if err := s.executeDeployment(sshService, conn, app, predefinedApp); err != nil {
		return s.handleDeploymentError(token, accountID, app, fmt.Errorf("deployment failed: %w", err))
	}

	// Handle post-deployment tasks
	if err := s.handlePostDeployment(token, accountID, app, sshService, conn); err != nil {
		log.Printf("Warning: post-deployment tasks failed: %v", err)
	}

	// Update application status to running
	app.Status = "Running"
	if err := s.appService.UpdateApplication(token, accountID, app); err != nil {
		log.Printf("Warning: failed to update application status: %v", err)
	}

	return nil
}

// UpgradeApplication upgrades an existing application to a new version
func (s *SimpleDeploymentService) UpgradeApplication(token, accountID, appID, version string) error {
	// Get application
	app, err := s.appService.GetApplication(token, accountID, appID)
	if err != nil {
		return fmt.Errorf("failed to get application: %w", err)
	}

	// Update application status
	app.Status = "Upgrading"
	app.AppVersion = version
	if err := s.appService.UpdateApplication(token, accountID, app); err != nil {
		log.Printf("Warning: failed to update application status: %v", err)
	}

	// Use existing services
	vpsService := NewVPSService()
	sshService := NewSSHService()
	kvService := NewKVService()
	
	// Get VPS configuration
	serverID := utils.ParseInt(app.VPSID)
	vpsConfig, err := vpsService.ValidateVPSAccess(token, accountID, serverID)
	if err != nil {
		return s.handleUpgradeError(token, accountID, app, fmt.Errorf("failed to get VPS config: %w", err))
	}

	// Get SSH private key
	privateKey, err := kvService.GetSSHPrivateKey(token, accountID, serverID)
	if err != nil {
		return s.handleUpgradeError(token, accountID, app, fmt.Errorf("failed to get SSH key: %w", err))
	}

	// Establish SSH connection
	conn, err := sshService.GetOrCreateConnection(vpsConfig.PublicIPv4, vpsConfig.SSHUser, privateKey, serverID)
	if err != nil {
		return s.handleUpgradeError(token, accountID, app, fmt.Errorf("failed to connect to VPS: %w", err))
	}

	// Execute upgrade
	if err := s.executeUpgrade(sshService, conn, app, version); err != nil {
		return s.handleUpgradeError(token, accountID, app, fmt.Errorf("upgrade failed: %w", err))
	}

	// Update application status
	app.Status = "Running"
	if err := s.appService.UpdateApplication(token, accountID, app); err != nil {
		log.Printf("Warning: failed to update application status: %v", err)
	}

	return nil
}

// UninstallApplication removes an application deployment
func (s *SimpleDeploymentService) UninstallApplication(token, accountID, appID string) error {
	// Get application
	app, err := s.appService.GetApplication(token, accountID, appID)
	if err != nil {
		return fmt.Errorf("failed to get application: %w", err)
	}

	// Use existing services
	vpsService := NewVPSService()
	sshService := NewSSHService()
	kvService := NewKVService()
	
	// Get VPS configuration
	serverID := utils.ParseInt(app.VPSID)
	vpsConfig, err := vpsService.ValidateVPSAccess(token, accountID, serverID)
	if err != nil {
		return fmt.Errorf("failed to get VPS config: %w", err)
	}

	// Get SSH private key
	privateKey, err := kvService.GetSSHPrivateKey(token, accountID, serverID)
	if err != nil {
		return fmt.Errorf("failed to get SSH key: %w", err)
	}

	// Establish SSH connection
	conn, err := sshService.GetOrCreateConnection(vpsConfig.PublicIPv4, vpsConfig.SSHUser, privateKey, serverID)
	if err != nil {
		return fmt.Errorf("failed to connect to VPS: %w", err)
	}

	// Execute uninstall
	return s.executeUninstall(sshService, conn, app)
}

// executeDeployment performs the actual deployment
func (s *SimpleDeploymentService) executeDeployment(sshService *SSHService, conn *SSHConnection, app *models.Application, predefinedApp *models.PredefinedApplication) error {
	releaseName := fmt.Sprintf("%s-%s", app.AppType, app.ID)
	
	// Create namespace if it doesn't exist
	createNSCmd := fmt.Sprintf("kubectl create namespace %s --dry-run=client -o yaml | kubectl apply -f -", app.Namespace)
	if _, err := sshService.ExecuteCommand(conn, createNSCmd); err != nil {
		return fmt.Errorf("failed to create namespace: %w", err)
	}

	// Add Helm repository if specified
	if predefinedApp.HelmChart.Repository != "" {
		repoName := s.extractRepoName(predefinedApp.HelmChart.Repository)
		addRepoCmd := fmt.Sprintf("helm repo add %s %s", repoName, predefinedApp.HelmChart.Repository)
		if _, err := sshService.ExecuteCommand(conn, addRepoCmd); err != nil {
			return fmt.Errorf("failed to add Helm repository: %w", err)
		}

		updateRepoCmd := "helm repo update"
		if _, err := sshService.ExecuteCommand(conn, updateRepoCmd); err != nil {
			return fmt.Errorf("failed to update Helm repository: %w", err)
		}
	}

	// Generate values file (simplified for Phase 2)
	valuesFile := fmt.Sprintf("/tmp/helm-values-%s.yaml", releaseName)
	valuesContent := s.generateSimpleValues(predefinedApp, app.Subdomain, app.Domain, releaseName)
	writeCmd := fmt.Sprintf("cat > %s << 'EOF'\n%s\nEOF", valuesFile, valuesContent)
	
	if _, err := sshService.ExecuteCommand(conn, writeCmd); err != nil {
		return fmt.Errorf("failed to write values file: %w", err)
	}

	// Install Helm chart
	chartRef := s.buildChartReference(predefinedApp)
	installCmd := fmt.Sprintf("helm install %s %s -n %s -f %s --wait --timeout=10m", 
		releaseName, chartRef, app.Namespace, valuesFile)
	
	if _, err := sshService.ExecuteCommand(conn, installCmd); err != nil {
		return fmt.Errorf("failed to install Helm chart: %w", err)
	}

	// Clean up values file
	cleanupCmd := fmt.Sprintf("rm -f %s", valuesFile)
	sshService.ExecuteCommand(conn, cleanupCmd) // Ignore errors for cleanup

	return nil
}

// executeUpgrade performs application upgrade
func (s *SimpleDeploymentService) executeUpgrade(sshService *SSHService, conn *SSHConnection, app *models.Application, version string) error {
	releaseName := fmt.Sprintf("%s-%s", app.AppType, app.ID)
	
	// Basic upgrade command
	upgradeCmd := fmt.Sprintf("helm upgrade %s %s -n %s --set image.tag=%s --wait --timeout=10m", 
		releaseName, app.AppType, app.Namespace, version)
	
	if _, err := sshService.ExecuteCommand(conn, upgradeCmd); err != nil {
		return fmt.Errorf("failed to upgrade application: %w", err)
	}

	return nil
}

// executeUninstall performs application uninstall
func (s *SimpleDeploymentService) executeUninstall(sshService *SSHService, conn *SSHConnection, app *models.Application) error {
	releaseName := fmt.Sprintf("%s-%s", app.AppType, app.ID)
	
	// Uninstall Helm chart
	uninstallCmd := fmt.Sprintf("helm uninstall %s -n %s", releaseName, app.Namespace)
	if _, err := sshService.ExecuteCommand(conn, uninstallCmd); err != nil {
		return fmt.Errorf("failed to uninstall Helm chart: %w", err)
	}

	// Delete namespace if it's application-specific
	if strings.HasPrefix(app.Namespace, "app-") {
		deleteNSCmd := fmt.Sprintf("kubectl delete namespace %s --ignore-not-found=true", app.Namespace)
		if _, err := sshService.ExecuteCommand(conn, deleteNSCmd); err != nil {
			return fmt.Errorf("failed to delete namespace: %w", err)
		}
	}

	return nil
}

// Helper methods
func (s *SimpleDeploymentService) handleDeploymentError(token, accountID string, app *models.Application, err error) error {
	app.Status = "Failed"
	if updateErr := s.appService.UpdateApplication(token, accountID, app); updateErr != nil {
		log.Printf("Warning: failed to update application status after error: %v", updateErr)
	}
	return err
}

func (s *SimpleDeploymentService) handleUpgradeError(token, accountID string, app *models.Application, err error) error {
	// Try to get the real-time status to determine if we should mark as failed or running
	if status, statusErr := s.appService.GetApplicationRealTimeStatus(token, accountID, app); statusErr == nil {
		app.Status = status
	} else {
		app.Status = "Failed"
	}
	
	if updateErr := s.appService.UpdateApplication(token, accountID, app); updateErr != nil {
		log.Printf("Warning: failed to update application status after error: %v", updateErr)
	}
	return err
}

func (s *SimpleDeploymentService) handlePostDeployment(token, accountID string, app *models.Application, sshService *SSHService, conn *SSHConnection) error {
	releaseName := fmt.Sprintf("%s-%s", app.AppType, app.ID)
	
	// Wait for deployment to be ready
	waitCmd := fmt.Sprintf("kubectl wait --for=condition=ready pod -l app.kubernetes.io/instance=%s -n %s --timeout=300s", 
		releaseName, app.Namespace)
	sshService.ExecuteCommand(conn, waitCmd) // Don't fail if wait times out
	
	// Additional post-deployment tasks can be added here
	return nil
}

func (s *SimpleDeploymentService) extractRepoName(repoURL string) string {
	parts := strings.Split(strings.TrimSuffix(repoURL, "/"), "/")
	if len(parts) > 0 {
		return parts[len(parts)-1]
	}
	return "repo"
}

func (s *SimpleDeploymentService) buildChartReference(predefinedApp *models.PredefinedApplication) string {
	if predefinedApp.HelmChart.Repository != "" {
		repoName := s.extractRepoName(predefinedApp.HelmChart.Repository)
		return fmt.Sprintf("%s/%s", repoName, predefinedApp.HelmChart.Chart)
	}
	return predefinedApp.HelmChart.Chart
}

func (s *SimpleDeploymentService) generateSimpleValues(predefinedApp *models.PredefinedApplication, subdomain, domain, releaseName string) string {
	// Generate basic values for common applications
	switch predefinedApp.ID {
	case "code-server":
		return fmt.Sprintf(`fullnameOverride: %s
ingress:
  enabled: true
  hosts:
  - host: %s.%s
    paths:
    - path: /
      pathType: Prefix
persistence:
  enabled: true
  size: 10Gi
password: "changeme"
`, releaseName, subdomain, domain)
	case "argocd":
		return fmt.Sprintf(`fullnameOverride: %s
server:
  ingress:
    enabled: true
    hosts:
    - %s.%s
configs:
  secret:
    argocdServerAdminPassword: "$2a$10$rRyBsGSHK6.uc8fntPwVIuLiQN7pNgwp0Kp/3S0w.HgNjXJZdh5Ji"
`, releaseName, subdomain, domain)
	default:
		return fmt.Sprintf(`fullnameOverride: %s
ingress:
  enabled: true
  hosts:
  - host: %s.%s
    paths:
    - path: /
      pathType: Prefix
`, releaseName, subdomain, domain)
	}
}