package services

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"github.com/chrishham/xanthus/internal/models"
)

// DeploymentStrategy defines the interface for application-specific deployment strategies
type DeploymentStrategy interface {
	// Deploy deploys the application using the strategy
	Deploy(conn *SSHConnection, app *models.Application, predefinedApp *models.PredefinedApplication) error
	
	// Upgrade upgrades the application to a new version
	Upgrade(conn *SSHConnection, app *models.Application, version string) error
	
	// Uninstall removes the application deployment
	Uninstall(conn *SSHConnection, app *models.Application) error
	
	// ValidateVersion validates if a version is supported
	ValidateVersion(version string) (bool, error)
}

// BaseDeploymentStrategy provides common deployment functionality
type BaseDeploymentStrategy struct {
	passwordService PasswordService
}

// NewBaseDeploymentStrategy creates a new BaseDeploymentStrategy
func NewBaseDeploymentStrategy(passwordService PasswordService) *BaseDeploymentStrategy {
	return &BaseDeploymentStrategy{
		passwordService: passwordService,
	}
}

// Deploy implements basic Helm deployment
func (s *BaseDeploymentStrategy) Deploy(conn *SSHConnection, app *models.Application, predefinedApp *models.PredefinedApplication) error {
	releaseName := fmt.Sprintf("%s-%s", app.AppType, app.ID)
	
	// Create namespace if it doesn't exist
	createNSCmd := fmt.Sprintf("kubectl create namespace %s --dry-run=client -o yaml | kubectl apply -f -", app.Namespace)
	if _, err := conn.Execute(createNSCmd); err != nil {
		return fmt.Errorf("failed to create namespace: %w", err)
	}

	// Add Helm repository if specified
	if predefinedApp.HelmChart.Repository != "" {
		// Extract repository name from URL
		repoName := s.extractRepoName(predefinedApp.HelmChart.Repository)
		addRepoCmd := fmt.Sprintf("helm repo add %s %s", repoName, predefinedApp.HelmChart.Repository)
		if _, err := conn.Execute(addRepoCmd); err != nil {
			return fmt.Errorf("failed to add Helm repository: %w", err)
		}

		// Update repository
		updateRepoCmd := "helm repo update"
		if _, err := conn.Execute(updateRepoCmd); err != nil {
			return fmt.Errorf("failed to update Helm repository: %w", err)
		}
	}

	// Generate values file
	valuesFile, err := s.generateValuesFile(conn, predefinedApp, app.Subdomain, app.Domain, releaseName)
	if err != nil {
		return fmt.Errorf("failed to generate values file: %w", err)
	}

	// Install Helm chart
	chartRef := s.buildChartReference(predefinedApp)
	installCmd := fmt.Sprintf("helm install %s %s -n %s -f %s --wait --timeout=10m", 
		releaseName, chartRef, app.Namespace, valuesFile)
	
	if _, err := conn.Execute(installCmd); err != nil {
		return fmt.Errorf("failed to install Helm chart: %w", err)
	}

	// Clean up values file
	cleanupCmd := fmt.Sprintf("rm -f %s", valuesFile)
	conn.Execute(cleanupCmd) // Ignore errors for cleanup

	return nil
}

// Upgrade implements basic Helm upgrade
func (s *BaseDeploymentStrategy) Upgrade(conn *SSHConnection, app *models.Application, version string) error {
	releaseName := fmt.Sprintf("%s-%s", app.AppType, app.ID)
	
	// Basic upgrade command - specific strategies can override this
	upgradeCmd := fmt.Sprintf("helm upgrade %s %s -n %s --set image.tag=%s --wait --timeout=10m", 
		releaseName, app.AppType, app.Namespace, version)
	
	if _, err := conn.Execute(upgradeCmd); err != nil {
		return fmt.Errorf("failed to upgrade application: %w", err)
	}

	return nil
}

// Uninstall implements basic Helm uninstall
func (s *BaseDeploymentStrategy) Uninstall(conn *SSHConnection, app *models.Application) error {
	releaseName := fmt.Sprintf("%s-%s", app.AppType, app.ID)
	
	// Uninstall Helm chart
	uninstallCmd := fmt.Sprintf("helm uninstall %s -n %s", releaseName, app.Namespace)
	if _, err := conn.Execute(uninstallCmd); err != nil {
		return fmt.Errorf("failed to uninstall Helm chart: %w", err)
	}

	// Delete namespace if it's application-specific
	if strings.HasPrefix(app.Namespace, "app-") {
		deleteNSCmd := fmt.Sprintf("kubectl delete namespace %s --ignore-not-found=true", app.Namespace)
		if _, err := conn.Execute(deleteNSCmd); err != nil {
			return fmt.Errorf("failed to delete namespace: %w", err)
		}
	}

	return nil
}

// ValidateVersion provides basic version validation
func (s *BaseDeploymentStrategy) ValidateVersion(version string) (bool, error) {
	// Basic validation - check if version is not empty
	if strings.TrimSpace(version) == "" {
		return false, fmt.Errorf("version cannot be empty")
	}
	return true, nil
}

// generateValuesFile creates a Helm values file from template
func (s *BaseDeploymentStrategy) generateValuesFile(conn *SSHConnection, predefinedApp *models.PredefinedApplication, subdomain, domain, releaseName string) (string, error) {
	valuesTemplate := predefinedApp.HelmChart.ValuesTemplate
	if valuesTemplate == "" {
		return "", fmt.Errorf("no values template specified")
	}

	// Read the template file
	templatePath := filepath.Join("configs", "helm-values", valuesTemplate)
	templateContent, err := ioutil.ReadFile(templatePath)
	if err != nil {
		return "", fmt.Errorf("failed to read values template: %w", err)
	}

	// Replace placeholders
	valuesContent := string(templateContent)
	
	// Standard placeholders
	replacements := map[string]string{
		"{{.Subdomain}}":   subdomain,
		"{{.Domain}}":      domain,
		"{{.ReleaseName}}": releaseName,
		"{{.Namespace}}":   fmt.Sprintf("app-%s", strings.ReplaceAll(subdomain, ".", "-")),
		"{{.FullDomain}}":  fmt.Sprintf("%s.%s", subdomain, domain),
	}

	// Add custom placeholders from predefined app
	for key, value := range predefinedApp.HelmChart.Placeholders {
		replacements[fmt.Sprintf("{{.%s}}", key)] = value
	}

	// Apply replacements
	for placeholder, value := range replacements {
		valuesContent = strings.ReplaceAll(valuesContent, placeholder, value)
	}

	// Write values to temporary file on VPS
	valuesFile := fmt.Sprintf("/tmp/helm-values-%s.yaml", releaseName)
	writeCmd := fmt.Sprintf("cat > %s << 'EOF'\n%s\nEOF", valuesFile, valuesContent)
	
	if _, err := conn.Execute(writeCmd); err != nil {
		return "", fmt.Errorf("failed to write values file: %w", err)
	}

	return valuesFile, nil
}

// extractRepoName extracts a repository name from a URL
func (s *BaseDeploymentStrategy) extractRepoName(repoURL string) string {
	// Simple extraction - use the last part of the path
	parts := strings.Split(strings.TrimSuffix(repoURL, "/"), "/")
	if len(parts) > 0 {
		return parts[len(parts)-1]
	}
	return "repo"
}

// buildChartReference builds the chart reference for Helm commands
func (s *BaseDeploymentStrategy) buildChartReference(predefinedApp *models.PredefinedApplication) string {
	if predefinedApp.HelmChart.Repository != "" {
		repoName := s.extractRepoName(predefinedApp.HelmChart.Repository)
		return fmt.Sprintf("%s/%s", repoName, predefinedApp.HelmChart.Chart)
	}
	return predefinedApp.HelmChart.Chart
}

// HelmChartInfo provides information about a Helm chart deployment
type HelmChartInfo struct {
	ReleaseName string
	Namespace   string
	Chart       string
	Version     string
	Status      string
}

// GetHelmChartInfo retrieves information about a deployed Helm chart
func GetHelmChartInfo(conn *SSHConnection, app *models.Application) (*HelmChartInfo, error) {
	releaseName := fmt.Sprintf("%s-%s", app.AppType, app.ID)
	
	// Get Helm release info
	statusCmd := fmt.Sprintf("helm status %s -n %s --output json", releaseName, app.Namespace)
	output, err := conn.Execute(statusCmd)
	if err != nil {
		return nil, fmt.Errorf("failed to get Helm status: %w", err)
	}

	// Parse basic info (simplified - in real implementation would use JSON parsing)
	info := &HelmChartInfo{
		ReleaseName: releaseName,
		Namespace:   app.Namespace,
		Chart:       app.AppType,
		Version:     app.AppVersion,
		Status:      "unknown",
	}

	// Extract status from output (simplified parsing)
	if strings.Contains(output, "deployed") {
		info.Status = "deployed"
	} else if strings.Contains(output, "failed") {
		info.Status = "failed"
	} else if strings.Contains(output, "pending") {
		info.Status = "pending"
	}

	return info, nil
}

// ValidateHelmTemplate validates a Helm template before deployment
func ValidateHelmTemplate(conn *SSHConnection, chartRef, valuesFile, namespace string) error {
	// Perform dry-run to validate template
	dryRunCmd := fmt.Sprintf("helm template test %s -n %s -f %s --dry-run", 
		chartRef, namespace, valuesFile)
	
	if _, err := conn.Execute(dryRunCmd); err != nil {
		return fmt.Errorf("template validation failed: %w", err)
	}

	return nil
}

// CreateConfigMap creates a Kubernetes ConfigMap
func CreateConfigMap(conn *SSHConnection, name, namespace string, data map[string]string) error {
	// Build ConfigMap YAML
	configMapYAML := fmt.Sprintf(`apiVersion: v1
kind: ConfigMap
metadata:
  name: %s
  namespace: %s
data:`, name, namespace)

	for key, value := range data {
		configMapYAML += fmt.Sprintf("\n  %s: |\n", key)
		// Indent the value content
		for _, line := range strings.Split(value, "\n") {
			configMapYAML += fmt.Sprintf("    %s\n", line)
		}
	}

	// Write ConfigMap to temporary file
	configMapFile := fmt.Sprintf("/tmp/configmap-%s.yaml", name)
	writeCmd := fmt.Sprintf("cat > %s << 'EOF'\n%s\nEOF", configMapFile, configMapYAML)
	
	if _, err := conn.Execute(writeCmd); err != nil {
		return fmt.Errorf("failed to write ConfigMap file: %w", err)
	}

	// Apply ConfigMap
	applyCmd := fmt.Sprintf("kubectl apply -f %s", configMapFile)
	if _, err := conn.Execute(applyCmd); err != nil {
		return fmt.Errorf("failed to apply ConfigMap: %w", err)
	}

	// Clean up
	cleanupCmd := fmt.Sprintf("rm -f %s", configMapFile)
	conn.Execute(cleanupCmd) // Ignore errors for cleanup

	return nil
}